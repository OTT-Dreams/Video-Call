<!DOCTYPE html>
<html>
  <head>
    <title>Secure Video Call</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      /* Your CSS same as before â€” skipped for brevity */
    </style>
  </head>
  <body>
    <video id="remoteVideo" autoplay></video>
    <video id="localVideo" autoplay muted></video>

    <div class="top-bar" id="topBar">
      <div class="id-tap" id="idDisplay" onclick="copyId()" title="Tap to copy ID">
        ID: <span class="id-wrapper"><span id="peerIdText">Loading...</span></span>
      </div>
      <input type="text" id="peerIdInput" placeholder="Enter Host ID" />
      <button id="joinBtn" onclick="startCall()">Join</button>
    </div>

    <div id="controls">
      <button class="ctrl-btn" id="videoBtn" onclick="toggleVideo()">
        <img src="https://cdn-icons-png.flaticon.com/512/5948/5948966.png" alt="Video">
      </button>
      <button class="ctrl-btn" id="audioBtn" onclick="toggleAudio()">
        <img src="https://cdn-icons-png.flaticon.com/512/5561/5561764.png" alt="Audio">
      </button>
      <button class="ctrl-btn end-call" onclick="endCall()">
        <img src="https://cdn-icons-png.flaticon.com/512/733/733497.png" alt="End">
      </button>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
      let peer, localStream, currentCall;

      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const peerIdText = document.getElementById("peerIdText");

      async function init() {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          localVideo.srcObject = localStream;
        } catch (err) {
          alert("Permission denied or device not found");
          console.error(err);
          return;
        }

        peer = new Peer();

        peer.on("open", id => {
          peerIdText.textContent = id;
        });

        peer.on("call", async call => {
          currentCall = call;
          call.answer(localStream);
          call.on("stream", stream => {
            remoteVideo.srcObject = stream;
          });

          call.peerConnection.addEventListener("connectionstatechange", () => {
            if (call.peerConnection.connectionState === "connected") {
              enableE2EE(call.peerConnection);
            }
          });
        });
      }

      async function startCall() {
        const remoteId = document.getElementById("peerIdInput").value;
        if (!remoteId) return;

        const call = peer.call(remoteId, localStream);
        currentCall = call;

        call.on("stream", stream => {
          remoteVideo.srcObject = stream;
        });

        call.peerConnection.addEventListener("connectionstatechange", () => {
          if (call.peerConnection.connectionState === "connected") {
            enableE2EE(call.peerConnection);
          }
        });
      }

      function toggleVideo() {
        const videoTrack = localStream.getVideoTracks()[0];
        videoTrack.enabled = !videoTrack.enabled;
        document.getElementById("videoBtn").classList.toggle("toggled-off", !videoTrack.enabled);
      }

      function toggleAudio() {
        const audioTrack = localStream.getAudioTracks()[0];
        audioTrack.enabled = !audioTrack.enabled;
        document.getElementById("audioBtn").classList.toggle("toggled-off", !audioTrack.enabled);
      }

      function endCall() {
        if (currentCall) {
          currentCall.close();
          remoteVideo.srcObject = null;
        }
      }

      function copyId() {
        navigator.clipboard.writeText(peerIdText.textContent);
        alert("ID copied!");
      }

      // Encryption setup (same as your original logic)
      const encoder = new TextEncoder();
      const SHARED_SECRET = "your-256-bit-secret-key--------";
      let encryptionKey;

      async function setupEncryptionKey() {
        encryptionKey = await crypto.subtle.importKey(
          "raw",
          encoder.encode(SHARED_SECRET),
          { name: "AES-GCM" },
          false,
          ["encrypt", "decrypt"]
        );
      }

      async function enableE2EE(pc) {
        const senders = pc.getSenders();
        for (const sender of senders) {
          const senderStreams = sender.createEncodedStreams();
          const transform = new TransformStream({
            async transform(chunk, controller) {
              const iv = crypto.getRandomValues(new Uint8Array(12));
              const encrypted = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv },
                encryptionKey,
                chunk.data
              );
              chunk.data = new Uint8Array([...iv, ...new Uint8Array(encrypted)]);
              controller.enqueue(chunk);
            },
          });
          senderStreams.readable.pipeThrough(transform).pipeTo(senderStreams.writable);
        }

        const receivers = pc.getReceivers();
        for (const receiver of receivers) {
          const receiverStreams = receiver.createEncodedStreams();
          const transform = new TransformStream({
            async transform(chunk, controller) {
              const iv = chunk.data.slice(0, 12);
              const encrypted = chunk.data.slice(12);
              try {
                const decrypted = await crypto.subtle.decrypt(
                  { name: "AES-GCM", iv },
                  encryptionKey,
                  encrypted
                );
                chunk.data = new Uint8Array(decrypted);
                controller.enqueue(chunk);
              } catch (e) {
                console.error("Decryption failed:", e);
              }
            },
          });
          receiverStreams.readable.pipeThrough(transform).pipeTo(receiverStreams.writable);
        }
      }

      // Init both key and video on load
      setupEncryptionKey();
      init();
    </script>
  </body>
</html>
